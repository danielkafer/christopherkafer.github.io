<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Mouse & WASD Descent</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Inter', sans-serif; user-select: none; }
        canvas { display: block; }
        #ui { position: absolute; top: 80px; left: 20px; color: white; pointer-events: none; }
        #controls-right { position: absolute; top: 20px; right: 20px; width: 250px; pointer-events: auto; }
        .gauge { position: absolute; bottom: 40px; right: 40px; text-align: right; color: white; pointer-events: none; }
        .panel { background: rgba(0, 0, 0, 0.7); padding: 20px; border-radius: 15px; border: 1px solid rgba(255, 255, 255, 0.15); backdrop-filter: blur(10px); }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #ef4444; }
        .home-btn { position: absolute; top: 20px; left: 20px; background: #e67e22; color: white; text-decoration: none; padding: 10px 15px; border-radius: 10px; font-size: 14px; font-weight: bold; z-index: 2000; cursor: pointer; border: none; box-shadow: 0 4px 0 #d35400; pointer-events: auto; }
        .home-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 #d35400; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; pointer-events: none; display: none; }
        #instruction { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.6); font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.1em; text-align: center; }
    </style>
</head>
<body>
    <a href="../index.html" class="home-btn">üè† HOME</a>
    <div id="ui" style="top: 80px;"> 
        <div class="panel">
            <div class="text-2xl font-black text-red-500 tracking-tighter uppercase italic">Altitude: <span id="heightDisplay">30</span>m</div>
            <div id="trick-display" class="text-xs font-bold text-yellow-400 mt-1 uppercase"></div>
            <div class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mt-1">WASD + Mouse Control Active</div>
        </div>
    </div>
    <div id="controls-right">
        <div class="panel">
            <label class="text-xs font-bold text-white uppercase block mb-2">Launch Altitude</label>
            <input type="range" id="heightSlider" min="10" max="1000" value="30">
            <button id="spawnBtn" class="w-full mt-4 bg-red-600 hover:bg-red-500 py-2 rounded font-black text-xs uppercase tracking-widest transition-all">Launch Bike</button>
        </div>
    </div>
    <div id="crosshair"></div>
    <div class="gauge">
        <div class="text-8xl font-black italic tracking-tighter leading-none"><span id="speedDisplay">0</span></div>
        <div class="text-xl opacity-40 font-bold uppercase tracking-widest">KM/H</div>
    </div>
    <div id="instruction">WASD: DRIVE | SPACE: JUMP | T: TAILWHIP | B: WHEELIE | N: NOHANDS<br>Inverted Look & Inverted Mouse Steer</div>
<script>
let scene, camera, renderer, wheels = [], bikeGroup = new THREE.Group();
let frontAssembly = new THREE.Group(), roadSegments = new THREE.Group(), clock = new THREE.Clock();
let pedalsGroup = new THREE.Group(), bodyParts = {}, audioCtx, windNoise, jumpSFX;
const SLOPE_ANGLE_DEG = 30, SLOPE_ANGLE_RAD = SLOPE_ANGLE_DEG * (Math.PI / 180);
const FLAT_LENGTH = 400, ROAD_WIDTH = 100, ROAD_THICKNESS = 1.5, DRAG_COEFF = 0.012; 
let state = { selectedHeight: 30, pos: new THREE.Vector3(0, 0, 0), rotation: Math.PI / 2, velocity: 0, gameActive: false, camYaw: 0, camPitch: 0.2, inputSteer: 0, inputThrottle: 0, isDriving: false, jumpY: 0, jumpVel: 0, isGrounded: true, pedalAngle: 0 };
const keys = {};
function init() {
    scene = new THREE.Scene(); scene.background = new THREE.Color(0x87ceeb); scene.fog = new THREE.Fog(0x87ceeb, 500, 6000);
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 30000);
    renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement); scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const sun = new THREE.DirectionalLight(0xffffff, 1.2); sun.position.set(1000, 2000, 1000); sun.castShadow = true;
    sun.shadow.camera.left = -2000; sun.shadow.camera.right = 2000; sun.shadow.camera.top = 2000; sun.shadow.camera.bottom = -2000;
    scene.add(sun); createEnvironment(); createGameBike(); setupControls(); initAudio();
    window.addEventListener('resize', onWindowResize, false); requestAnimationFrame(animate);
}
function initAudio() {
    const startAudio = () => {
        if (audioCtx) return; audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const bufferSize = 2 * audioCtx.sampleRate, noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const output = noiseBuffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
        windNoise = audioCtx.createBufferSource(); windNoise.buffer = noiseBuffer; windNoise.loop = true;
        const windGain = audioCtx.createGain(); windGain.gain.value = 0; state.windGain = windGain;
        const filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 400; state.windFilter = filter;
        windNoise.connect(filter); filter.connect(windGain); windGain.connect(audioCtx.destination);
        windNoise.start(); window.removeEventListener('mousedown', startAudio);
    };
    window.addEventListener('mousedown', startAudio);
}
function createHouse(x, z) {
    const house = new THREE.Group(); const body = new THREE.Mesh(new THREE.BoxGeometry(15, 12, 15), new THREE.MeshPhongMaterial({color: 0xcccccc}));
    body.position.y = 6; house.add(body); const roof = new THREE.Mesh(new THREE.ConeGeometry(12, 8, 4), new THREE.MeshPhongMaterial({color: 0x442211}));
    roof.position.y = 16; roof.rotation.y = Math.PI/4; house.add(roof); house.position.set(x, 0, z); scene.add(house);
}
function createEnvironment() {
    scene.add(roadSegments); const grassMat = new THREE.MeshPhongMaterial({ color: 0x2d5a27 }), sandMat = new THREE.MeshPhongMaterial({ color: 0xd2b48c });
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(80000, 80000), grassMat); ground.rotation.x = -Math.PI / 2; ground.position.y = -1; scene.add(ground);
    const dune1 = new THREE.Mesh(new THREE.CircleGeometry(300, 32), sandMat); dune1.rotation.x = -Math.PI/2; dune1.position.set(600, -0.5, 1000); scene.add(dune1);
    const dune2 = new THREE.Mesh(new THREE.CircleGeometry(200, 32), sandMat); dune2.rotation.x = -Math.PI/2; dune2.position.set(800, -0.5, 2500); scene.add(dune2);
    const barn = new THREE.Mesh(new THREE.BoxGeometry(40, 25, 60), new THREE.MeshPhongMaterial({color: 0xaa2222})); barn.position.set(-500, 12.5, 1500); scene.add(barn);
    for(let i=0; i<10; i++){ createHouse(-150, -i * 50); createHouse(150, -i * 50); }
}
function updateTerrain(height) {
    roadSegments.clear(); const roadMat = new THREE.MeshPhongMaterial({ color: 0x444444 }), sidewalkMat = new THREE.MeshPhongMaterial({ color: 0x999999 });
    const slopeLen = height / Math.sin(SLOPE_ANGLE_RAD), slopeHoriz = slopeLen * Math.cos(SLOPE_ANGLE_RAD);
    const segs = [ { w: ROAD_WIDTH, h: ROAD_THICKNESS, l: FLAT_LENGTH, y: height - ROAD_THICKNESS, z: -FLAT_LENGTH/2, rx: 0 }, { w: ROAD_WIDTH, h: ROAD_THICKNESS, l: slopeLen, y: height/2 - ROAD_THICKNESS, z: slopeHoriz/2, rx: SLOPE_ANGLE_RAD }, { w: ROAD_WIDTH, h: ROAD_THICKNESS, l: FLAT_LENGTH * 20, y: -ROAD_THICKNESS, z: slopeHoriz + (FLAT_LENGTH * 10), rx: 0 } ];
    segs.forEach(s => {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(s.w, s.h, s.l), roadMat); mesh.position.set(0, s.y, s.z); mesh.rotation.x = s.rx; roadSegments.add(mesh);
        const swL = new THREE.Mesh(new THREE.BoxGeometry(15, s.h + 0.5, s.l), sidewalkMat); swL.position.set(-(s.w/2 + 7.5), s.y + 0.2, s.z); swL.rotation.x = s.rx; roadSegments.add(swL);
        const swR = swL.clone(); swR.position.x = s.w/2 + 7.5; roadSegments.add(swR);
    });
}
function createGameBike() {
    const frameMat = new THREE.MeshPhongMaterial({ color: 0xef4444 }), chromeMat = new THREE.MeshPhongMaterial({ color: 0xcccccc }), tireMat = new THREE.MeshPhongMaterial({ color: 0x111111 }), skinMat = new THREE.MeshPhongMaterial({ color: 0xffdbac }), shirtMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
    const mkWheel = () => { const g = new THREE.Group(); g.add(new THREE.Mesh(new THREE.TorusGeometry(1, 0.2, 16, 40), tireMat)); g.add(new THREE.Mesh(new THREE.TorusGeometry(0.85, 0.05, 8, 40), chromeMat)); g.rotation.y = Math.PI / 2; return g; };
    const bW = mkWheel(); bW.position.set(0, 1, -2.5); bikeGroup.add(bW); wheels.push(bW);
    const fW = mkWheel(); fW.position.set(0, -0.8, 0); frontAssembly.add(fW); wheels.push(fW);
    frontAssembly.add(new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 2.5), chromeMat));
    const bars = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 2.6), chromeMat); bars.rotation.z = Math.PI/2; bars.position.y = 1.3;
    frontAssembly.add(bars); frontAssembly.position.set(0, 1.8, 1.6); bikeGroup.add(frontAssembly);
    const frame = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 3.2), frameMat); frame.rotation.x = Math.PI/2; frame.position.y = 1.6; bikeGroup.add(frame);
    const crank = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.4), chromeMat); crank.rotation.z = Math.PI/2; pedalsGroup.add(crank);
    const pL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.3), shirtMat); pL.position.set(-0.7, 0, 0.4); pedalsGroup.add(pL);
    const pR = pL.clone(); pR.position.set(0.7, 0, -0.4); pedalsGroup.add(pR); pedalsGroup.position.set(0, 1.2, 0); bikeGroup.add(pedalsGroup);
    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.1, 0.4), shirtMat); torso.position.set(0, 2.7, -0.5); bikeGroup.add(torso);
    bodyParts.armL = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 1.4), skinMat); bodyParts.armL.position.set(-0.5, 3.1, 0.2); bodyParts.armL.rotation.x = Math.PI/3; bikeGroup.add(bodyParts.armL);
    bodyParts.armR = bodyParts.armL.clone(); bodyParts.armR.position.x = 0.5; bikeGroup.add(bodyParts.armR);
    bodyParts.legL = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.12, 1.5), shirtMat); bodyParts.legL.position.set(-0.3, 1.8, -0.3); bikeGroup.add(bodyParts.legL);
    bodyParts.legR = bodyParts.legL.clone(); bodyParts.legR.position.x = 0.3; bikeGroup.add(bodyParts.legR);
    scene.add(bikeGroup); bikeGroup.visible = false;
}
function spawn() {
    state.selectedHeight = parseInt(document.getElementById('heightSlider').value); state.pos.set(0, state.selectedHeight, -50);
    state.velocity = 0; state.rotation = Math.PI / 2; state.jumpY = 0; state.jumpVel = 0; state.gameActive = true; bikeGroup.visible = true;
    updateTerrain(state.selectedHeight); document.getElementById('heightDisplay').innerText = state.selectedHeight;
}
function setupControls() {
    document.getElementById('heightSlider').oninput = (e) => { document.getElementById('heightDisplay').innerText = e.target.value; };
    document.getElementById('spawnBtn').onclick = spawn;
    window.addEventListener('keydown', (e) => { keys[e.code] = true; if(e.code === 'Space' && state.isGrounded) state.jumpVel = 14; });
    window.addEventListener('keyup', (e) => keys[e.code] = false);
    window.addEventListener('mousedown', (e) => { if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') { state.isDriving = true; document.getElementById('crosshair').style.display = 'block'; } });
    window.addEventListener('mouseup', () => { state.isDriving = false; state.inputSteer = 0; state.inputThrottle = 0; document.getElementById('crosshair').style.display = 'none'; });
    window.addEventListener('mousemove', (e) => {
        if (state.isDriving) { state.inputSteer = (e.clientX - window.innerWidth / 2) / (window.innerWidth / 4); state.inputSteer = Math.max(-1, Math.min(1, state.inputSteer));
            state.inputThrottle = (window.innerHeight / 2 - e.clientY) / (window.innerHeight / 4); state.inputThrottle = Math.max(-1, Math.min(1, state.inputThrottle));
        } else { state.camYaw += e.movementX * 0.005; state.camPitch += e.movementY * 0.005; state.camPitch = Math.max(-0.6, Math.min(1.1, state.camPitch)); }
    });
}
function handleTricks() {
    const ui = document.getElementById('trick-display');
    if(keys['KeyT']) { bikeGroup.rotation.z += 0.4; ui.innerText = "Tailwhip!"; }
    else if(keys['KeyB']) { bikeGroup.rotation.x = -0.6; ui.innerText = "Wheelie!"; }
    else if(keys['KeyN']) { bodyParts.armL.position.y = 4.2; bodyParts.armR.position.y = 4.2; ui.innerText = "No Hands!"; }
    else { bikeGroup.rotation.z = 0; bikeGroup.rotation.x = 0; bodyParts.armL.position.y = 3.1; bodyParts.armR.position.y = 3.1; ui.innerText = ""; }
}
function updatePhysics(dt) {
    if (!state.gameActive) return;
    let accelForce = 0; if (keys['KeyW']) accelForce += 15; if (state.inputThrottle > 0) accelForce += state.inputThrottle * 15;
    if (keys['KeyS'] || state.inputThrottle < 0) { if (state.velocity > 0.2) accelForce -= 35; else state.velocity = 0; }
    const drag = DRAG_COEFF * state.velocity * Math.abs(state.velocity); state.velocity += (accelForce - drag) * dt;
    if (state.velocity < 0) state.velocity = 0;
    let steerDir = -state.inputSteer; if (keys['KeyA']) steerDir += 0.8; if (keys['KeyD']) steerDir -= 0.8;
    const velocityFactor = Math.min(1, Math.abs(state.velocity) / 3), damping = 1.0 / (1.0 + Math.abs(state.velocity) * 0.04);
    state.rotation += steerDir * 2.5 * velocityFactor * damping * dt;
    const slopeHoriz = state.selectedHeight / Math.tan(SLOPE_ANGLE_RAD);
    if (state.pos.z > 0 && state.pos.z < slopeHoriz) { const lookDownhill = Math.cos(state.rotation); state.velocity += lookDownhill * 20 * Math.sin(SLOPE_ANGLE_RAD) * dt; }
    state.jumpVel -= 35 * dt; state.jumpY += state.jumpVel * dt; if(state.jumpY <= 0) { state.jumpY = 0; state.isGrounded = true; } else state.isGrounded = false;
    const move = new THREE.Vector3(0, 0, state.velocity * dt * 25); move.applyAxisAngle(new THREE.Vector3(0, 1, 0), state.rotation); state.pos.add(move);
    const hw = ROAD_WIDTH/2 - 5; if (state.pos.x > hw) state.pos.x = hw; if (state.pos.x < -hw) state.pos.x = -hw;
    let terrainY = 0; if (state.pos.z < 0) terrainY = state.selectedHeight; else if (state.pos.z < slopeHoriz) terrainY = state.selectedHeight - (state.pos.z * (state.selectedHeight / slopeHoriz));
    state.pos.y = terrainY; const currentAlt = state.pos.y + state.jumpY;
    bikeGroup.position.set(state.pos.x, currentAlt, state.pos.z); bikeGroup.rotation.y = state.rotation; frontAssembly.rotation.y = steerDir * 0.3;
    if (state.pos.z > 0 && state.pos.z < slopeHoriz) bikeGroup.rotation.x = Math.cos(state.rotation) * SLOPE_ANGLE_RAD; else bikeGroup.rotation.x = 0;
    state.pedalAngle += state.velocity * 0.25; pedalsGroup.rotation.x = state.pedalAngle; wheels.forEach(w => w.rotation.x += state.velocity * 12 * dt);
    bodyParts.legL.rotation.x = Math.sin(state.pedalAngle) * 0.5; bodyParts.legR.rotation.x = Math.sin(state.pedalAngle + Math.PI) * 0.5;
    handleTricks(); document.getElementById('speedDisplay').innerText = Math.floor(state.velocity * 18); document.getElementById('heightDisplay').innerText = Math.floor(currentAlt);
    if (state.windGain) { const vol = Math.min(1, state.velocity / 120); state.windGain.gain.setTargetAtTime(vol * 0.5, audioCtx.currentTime, 0.1); state.windFilter.frequency.setTargetAtTime(400 + (vol * 5000), audioCtx.currentTime, 0.1); }
    const dist = 22; camera.position.set(state.pos.x + dist * Math.sin(state.camYaw) * Math.cos(state.camPitch), currentAlt + dist * Math.sin(state.camPitch) + 5, state.pos.z - dist * Math.cos(state.camYaw) * Math.cos(state.camPitch));
    camera.lookAt(state.pos.x, currentAlt + 2, state.pos.z);
}
function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
function animate() { requestAnimationFrame(animate); const dt = clock.getDelta(); if (dt < 0.1) updatePhysics(dt); renderer.render(scene, camera); }
window.onload = init;
</script>
</body>
</html>
